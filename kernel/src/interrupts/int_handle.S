/* * bekOS is a basic OS for the Raspberry Pi * Copyright (C) 2023 Bekos Contributors * * This program is free software: you can redistribute it and/or modify * it under the terms of the GNU General Public License as published by * the Free Software Foundation, either version 3 of the License, or * (at your option) any later version. * * This program is distributed in the hope that it will be useful, * but WITHOUT ANY WARRANTY; without even the implied warranty of * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the * GNU General Public License for more details. * * You should have received a copy of the GNU General Public License * along with this program.  If not, see <https://www.gnu.org/licenses/>. */// clang-format off#include "arch/a64/asm_defines.h"#include "process/syscall_handling.h".section ".text.vec".macro adrl, dst, sym    adrp    \dst, \sym    add     \dst, \dst, :lo12:\sym.endm.macro complain_unknown_interrupt num    mov     x0, #\num    mrs     x1, esr_el1    mrs     x2, elr_el1    mrs     x3, spsr_el1    mrs     x4, far_el1    mov     x30, x2     // Deeply cursed and forbidden.//    adrl    x5, __stack_top // Deeperly cursed - just in case error is stack overflow.//    mov     sp, x5    b unknown_int_handler1:  wfe    b 1b.endm.macro handle_basic_interrupt    store_regs    // Arguments    mrs	x0, esr_el1    mrs	x1, elr_el1    bl handle_hardware_interrupt    restore_regs    eret.endm.macro handle_syscall    store_regs    // Store syndrome register    mrs x24, ESR_EL1    // Extract interrupt type    lsr w25, w24, #26    // Check it is syscall    cmp w25, #21    b.ne 2f    bl enable_interrupts    mov x29, xzr    mov x30, xzr    bl handle_syscall_hard    str x0, [sp, #0]    bl disable_interrupts    // Override x0 - return value - before restoring    restore_regs    eret2:  mov     x0, 8    mrs     x1, esr_el1    mrs     x2, elr_el1    mrs     x3, spsr_el1    mrs     x4, far_el1    mov     x30, x2     // Deeply cursed and forbidden.//    adrl    x5, __stack_top // Deeperly cursed - just in case error is stack overflow.//    mov     sp, x5    b unknown_int_handler3:  wfe    b 3b.endm.macro store_regs    sub	sp, sp, #STACK_REGISTER_HEADER_SZ    // Store General Purpose registers	stp	x0, x1, [sp, #16 * 0]	stp	x2, x3, [sp, #16 * 1]	stp	x4, x5, [sp, #16 * 2]	stp	x6, x7, [sp, #16 * 3]	stp	x8, x9, [sp, #16 * 4]	stp	x10, x11, [sp, #16 * 5]	stp	x12, x13, [sp, #16 * 6]	stp	x14, x15, [sp, #16 * 7]	stp x16, x17, [sp, #16 * 8]	stp x18, x19, [sp, #16 * 9]	stp x20, x21, [sp, #16 * 10]	stp x22, x23, [sp, #16 * 11]	stp x24, x25, [sp, #16 * 12]	stp x26, x27, [sp, #16 * 13]	stp x28, x29, [sp, #16 * 14]	// Store x30 and el0's stack pointer (just in case...)	mrs x21, SP_EL0	stp x30, x21, [sp, #16 * 15]	// Store the return registers - for nested interrupts    mrs x21, SPSR_EL1    mrs x22, ELR_EL1    stp x21, x22, [sp, #16 * 16].endm.macro restore_regs    // Restore exception regs    ldp x0, x1, [sp, #16 * 16]    msr SPSR_EL1, x0    msr ELR_EL1, x1    // Restore x30 and el0's stack pointer (just in case...)    ldp x30, x0, [sp, #16 * 15]    msr SP_EL0, x0    // Restore general regs    ldp	x0, x1, [sp, #16 * 0]    ldp	x2, x3, [sp, #16 * 1]    ldp	x4, x5, [sp, #16 * 2]    ldp	x6, x7, [sp, #16 * 3]    ldp	x8, x9, [sp, #16 * 4]    ldp	x10, x11, [sp, #16 * 5]    ldp	x12, x13, [sp, #16 * 6]    ldp	x14, x15, [sp, #16 * 7]    ldp x16, x17, [sp, #16 * 8]    ldp x18, x19, [sp, #16 * 9]    ldp x20, x21, [sp, #16 * 10]    ldp x22, x23, [sp, #16 * 11]    ldp x24, x25, [sp, #16 * 12]    ldp x26, x27, [sp, #16 * 13]    ldp x28, x29, [sp, #16 * 14]    add sp, sp, #STACK_REGISTER_HEADER_SZ.endm.macro vector_entry branchlabel.align 7b \branchlabel.endm// VBAR has reserved 0 bottom 11 bits.align 11.globl irq_vectorsirq_vectors:    vector_entry el1_s0_sync    vector_entry el1_s0_irq    vector_entry el1_s0_fiq    vector_entry el1_s0_err    vector_entry el1_s1_sync    vector_entry el1_s1_irq    vector_entry el1_s1_fiq    vector_entry el1_s1_err    vector_entry el0_64_sync    vector_entry el0_64_irq    vector_entry el0_64_fiq    vector_entry el0_64_err    vector_entry el0_32_sync    vector_entry el0_32_irq    vector_entry el0_32_fiq    vector_entry el0_32_errel1_s0_sync:    complain_unknown_interrupt 0el1_s0_irq:    complain_unknown_interrupt 1el1_s0_fiq:    complain_unknown_interrupt 2el1_s0_err:    complain_unknown_interrupt 3el1_s1_sync:    complain_unknown_interrupt 4el1_s1_irq:    // complain_unknown_interrupt 5    handle_basic_interruptel1_s1_fiq:    complain_unknown_interrupt 6el1_s1_err:    complain_unknown_interrupt 7el0_64_sync:    handle_syscall    //complain_unknown_interrupt 8el0_64_irq:    handle_basic_interrupt    //complain_unknown_interrupt 9el0_64_fiq:    complain_unknown_interrupt 10el0_64_err:    complain_unknown_interrupt 11el0_32_sync:    complain_unknown_interrupt 12el0_32_irq:    complain_unknown_interrupt 13el0_32_fiq:    complain_unknown_interrupt 14el0_32_err:    complain_unknown_interrupt 15.section ".text"ASM_FUNCTION_BEGIN(userspace_return_from_fork)    bl  disable_interrupts   // Interrupts at this point could be disasterous    str xzr, [sp, #0]       // Return 0 from fork.    restore_regs    eretASM_FUNCTION_END(userspace_return_from_fork)